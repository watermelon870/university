9.1) c++에서 연산자는 함수로 구현됩니다. 존재하지 않는 return형식에 대해서는 컴파일 에러. 예외존재/기본적으로 존재하는 연산자만 overloading가능/ *적어도 하나는 사용자 정의형식
9.2)member function방법, *friend function 방법, normal function 방법
함수 프로토타입으로 선언 가능, 바깥쪽에서 선언도 가능
 두 개의 함수, 즉 각각의 경우에 하나씩을 작성해야합니다. // 
9.2a)앞의 friend에서 만든 + 에 대한 overload는 사실 direct acess가 필요 없으니 그냥 normal 함수 방법으로 할 수 있다
 friend와 normal 둘 다 사용 가능하면 normal쓰자!
9.3) << overloading
std::cout 왼쪽 피연산자 your Point class object 오른쪽 피연산자인 연산자!
std::ostream과 std::istream int나 char같은 일종의 type이라고 생각하면 됨
연산자 << 및 연산자 >>를 오버로드하면 클래스를 화면 출력하고 콘솔에서 사용자 입력을 받아들이 기가 매우 쉽습니다 ---->>> 결론 윗부분 샘플프로그램 보면 이해가 쉬움
9.4)member function 방법
friend와 비교해서 달라진 부분 - > line 12에서 왼쪽 value가 사라짐, line 20과 21에서 cents.m_cents대신 m_cents
??2. 왼쪽 매개 변수는 이제 암시 적 * this 개체가되므로 제거됩니다. 외...
모든것이 친구기능으로 오버로드xxx 맴버함수또한 마찬가지
9.5)단항 연산자이므로 매개 변수를 사용하지 않습니다    -, +, bool등
9.6)비교 연산자는 모두 왼쪽 피연산자를 수정하지 않는 이진 연산자이므로 오버로드 된 비교 연산자 friend 함수를 만듭니다.
9.7)증가 및 감소 연산자는 단항 연산자이므로 피연산자를 수정하므로 멤버 함수로 가장 많이 오버로드됩니다.  overload operater로 생각하면 prefix와 postfix 둘 다 같은 모습을 갖는다...  postfix의 경우는 더미인수를 활용해서 구별해준다!
9.8)[]연산자 오버로딩 - > 1차원 array에서 사용 const로도 사용 가능 또한 함수 매개 변수가 정수 일 필요는 없다! 
9.9)()연산자 오버로딩 - > 2차원 array에서 사용 const로 사용 가능 // 매개변수를 사용하지 않는 방법을 사용하면 초기화로 사용 가능 // functor(function object)를 사용하면 함수와 다르게 필요한만큼 많은 functor 객체를 동시에 사용 가능, 맴버 변수이기때문에 데이터 저장 가능
9.10) 형변환 오버로딩 - > ()오버로딩을 이용해서 쉽게 이용 가능
9.11) 복사 생성자 - >  초기화 방법 크게 3가지 < 직접초기화, c++초기화, 복사 초기화 > 이 중 복사초기화 생각 해 보자 
맴버함수로서 복사 생성자를 만들어서 작업 가능하다 // ??memberwise 초기화?? // private에 넣어서 복사본을 만들지 못하게 할수도 있고 직접초기화의 과정으로 바뀌에서 실행될 수도 있다(성능상의 이유) 그러니 복사초기화는 안 쓰는 것이 좋다
9.12)복사 초기화 - > 안 쓰는 것이 좋다
9.13)converting constructors - > 암시적인 방법에서는 문제가 발생하기 쉬우므로 명시적인 방법이 좋다
explicit // implicit 전송을 막아주고 explicit전송만 허가 해 준다 //변환되는 것을 완전히 금지하고 싶습니다 - > delete키워드 사용 - > 해당 함수가 사용하지 못하도록 삭제 가능
9.14) = 연산자 오버로딩 - > 멤버 함수로 오버로드 // C ++은 자체 할당을 허용합니다. 그런데 동적할당일 경우에 dangling pointer문제가 발생 가능 - > 자체 할당 감지로 처리하면 됨
9.15) 동적으로 할당 된 메모리를 처리하는 클래스를 설계 할 때 얕은 복사가 문제가 될 수 있다 왜냐하면 포인터의 주소를 복사하기 때문입니다 - 메모리를 할당하지 않거나 가리키는 내용을 복사하지 않습니다! // 깊은 복사 방법 - > 그 문자열의 복사본을 보관하기에 충분한 메모리를 할당합니다 (11 행). 마지막으로 문자열 (14 줄과 15 줄)을 수동으로 복사해야합니다. 또는 오버로드된 =연산자